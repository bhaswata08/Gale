from langchain_core.documents import Document

content = Document(page_content="""DeepSeek-V2: A Strong, Economical, and Efficient Mixture-of-Experts Language Model\n\nDeepSeek-AI\n\nresearch@deepseek.com\n\nAbstract\n\nWe present DeepSeek-V2, a strong Mixture-of-Experts (MoE) language model characterized by economical training and efficient inference. It comprises 236B total parameters, of which 21B are activated for each token, and supports a context length of 128K tokens. DeepSeek-V2 adopts innovative architectures including Multi-head Latent Attention (MLA) and DeepSeekMoE. MLA guarantees efficient inference through significantly compressing the Key-Value (KV) cache into a latent vector, while DeepSeekMoE\n\nenables training strong models at an economical cost through sparse computation. Compared with DeepSeek 67B, DeepSeek-V2 achieves significantly stronger performance, and meanwhile saves 42.5% of training costs, reduces the KV cache by 93.3%, and boosts the maximum generation throughput to 5.76 times. We pretrain DeepSeek-V2 on a high-quality and multi-source corpus consisting of 8.1T tokens, and further perform Supervised Fine-Tuning (SFT) and Reinforcement Learning (RL) to fully unlock its\n\npotential. Evaluation results show that, even with only 21B activated parameters, DeepSeek-V2 and its chat versions still achieve top-tier performance among open-source models. The model checkpoints are available at https://github.com/deepseek-ai/DeepSeek-V2.\n\n= E\n\n) v E E â‚¬ g\n\nTraining Costs (K GPU Hours/T Tokens)\n\n(a)  (b) \n\nFigure 1 | (a) MMLU accuracy vs. activated parameters, among different open-source models. (b) Training costs and inference efficiency of DeepSeek 67B (Dense) and DeepSeek-V2. Introduction\n\nIn the past few years, Large Language Models (LLMs) (Anthropic, 2023; Google, 2023; OpenAI, 2022, 2023) have undergone rapid development, offering a glimpse into the dawn of Artificial General Intelligence (AGI). In general, the intelligence of an LLM tends to improve as the number of parameters increases, allowing it to exhibit emergent capabilities across various tasks (Wei et al., 2022). However, the improvement comes at the cost of larger computing resources for training and a potential\n\ndecrease in inference throughput. These constraints present significant challenges that impede the widespread adoption and utilization of LLMs. In order to tackle this problem, we introduce DeepSeek-V2, a strong open-source Mixture-of-Experts (MoE) language model, characterized by economical training and efficient inference through an innovative Transformer architecture. It is equipped with a total of 236B parameters, of which 21B are activated for each token, and supports a context length of\n\n128K tokens.\n\nWe optimize the attention modules and Feed-Forward Networks (FFNs) within the Trans- former framework (Vaswani et al., 2017) with our proposed Multi-head Latent Attention (MLA) and DeepSeekMoE. (1) In the context of attention mechanisms, the Key-Value (KV) cache of the Multi-Head Attention (MHA) (Vaswani et al., 2017) poses a significant obstacle to the inference efficiency of LLMs. Various approaches have been explored to address this issue, including Grouped-Query Attention (GQA) (Ainslie et\n\nal., 2023) and Multi-Query Attention (MQA) (Shazeer, 2019). However, these methods often compromise performance in their attempt to reduce the KV cache. In order to achieve the best of both worlds, we introduce MLA, an attention mechanism equipped with low-rank key-value joint compression. Empirically, MLA achieves superior performance compared with MHA, and meanwhile significantly reduces the KV cache during inference, thus boosting the inference efficiency. (2) For Feed-Forward Networks\n\n(FFNs), we follow the DeepSeekMoE architecture (Dai et al., 2024), which adopts fine-grained expert segmentation and shared expert isolation for higher potential in expert specialization. The DeepSeekMoE architecture demonstrates great advantages compared with conventional MoE architectures like GShard (Lepikhin et al., 2021), enabling us to train strong models at an economical cost. As we employ expert parallelism during training, we also devise supplementary mechanisms to control communication\n\noverheads and ensure load balance. By combining these two techniques, DeepSeek-V2 features strong performance (Figure 1(a)), economical training costs, and efficient inference throughput (Figure 1(b)), simultaneously.\n\nWe construct a high-quality and multi-source pre-training corpus consisting of 8.1T tokens. Compared with the corpus used in DeepSeek 67B (our previous release) (DeepSeek-AI, 2024), this corpus features an extended amount of data, especially Chinese data, and higher data quality. We first pretrain DeepSeek-V2 on the full pre-training corpus. Then, we collect 1.5M conversational sessions, which encompass various domains such as math, code, writing, reasoning, safety, and more, to perform\n\nSupervised Fine-Tuning (SFT) for DeepSeek-V2 Chat (SFT). Finally, we follow DeepSeekMath (Shao et al., 2024) to employ Group Relative Policy Optimization (GRPO) to further align the model with human preference and produce DeepSeek-V2 Chat (RL).\n\nWe evaluate DeepSeek-V2 on a wide range of benchmarks in English and Chinese, and compare it with representative open-source models. Evaluation results show that even with only 21B activated parameters, DeepSeek-V2 still achieves top-tier performance among open-source models and becomes the strongest open-source MoE language model. Figure 1(a) highlights that, on MMLU, DeepSeek-V2 achieves top-ranking performance with only a small number of activated parameters. In addition, as shown in Figure\n\n1(b), compared with DeepSeek 67B, DeepSeek-V2 saves 42.5% of training costs, reduces the KV cache by 93.3%, and boosts the maximum generation throughput to 5.76 times. We also evaluate DeepSeek-V2 Chat (SFT) and\n\n4\n\nO000 ~~ O000 D Routed Expert i u Shared Expert Transformer Block xL | : [ S | 1 1 P ! 1 - H 1 1 | : Feed-Forward Network <~. l 1 | S S~s : 1 1 y 1 I B S N : | RMS Norm ! ! 1 \\ J 1 1 1 1 I I 1 I 1 1 > : M 1 | r ! [ Cached During Inference ! Attention <* idd H e \\I\\\\ Output Hiddenu,(OOQOQO -~ ~ OOOO 1 1 ~ . Lot | Multi-Head Attention 1 | RMS Norm . i 1 1 C . aR C kR | â€” {laci a3 {[ke Â£} | ! g (ele]Â®) L | 1 concatenate {afy} g k{ @ (k) 00O (73] 00 apply apply ROPE ROPE Latent c? Latent cfV (S - S N\n\n1 1 1 1 | 1 1 1 1 | 1 1 1 1 1 1 | 1 1\n\nFigure 2 | Illustration of the architecture of DeepSeek-V2. MLA ensures efficient inference by significantly reducing the KV cache for generation, and DeepSeekMoE enables training strong models at an economical cost through the sparse architecture.\n\nDeepSeek-V2 Chat (RL) on open-ended benchmarks. Notably, DeepSeek-V2 Chat (RL) achieves 38.9 length-controlled win rate on AlpacaEval 2.0 (Dubois et al., 2024), 8.97 overall score on MT-Bench (Zheng et al., 2023), and 7.91 overall score on AlignBench (Liu et al., 2023). The English open-ended conversation evaluations demonstrate that DeepSeek-V2 Chat (RL) has top- tier performance among open-source chat models. In addition, the evaluation on AlignBench indicates that in Chinese, DeepSeek-V2 Chat\n\n(RL) outperforms all of open-source models, and even beats most of closed-source models.\n\nIn the rest of this paper, we first provide a detailed description of the model architecture of DeepSeek-V2 (Section 2). Subsequently, we introduce our pre-training endeavors, including the training data construction, hyper-parameter settings, infrastructures, long context extension, and the evaluation of model performance and efficiency (Section 3). Following this, we demon- strate our efforts in alignment, encompassing Supervised Fine-Tuning (SFT), Reinforcement Learning (RL), the evaluation\n\nresults, and other discussion (Section 4). Finally, we summarize the conclusion, deliberate on the current limitations of DeepSeek-V2, and outline our future work (Section 5).\n\n5\n\n2. Architecture\n\nBy and large, DeepSeek-V2 is still in the Transformer architecture (Vaswani et al., 2017), where each Transformer block consists of an attention module and a Feed-Forward Network (FFN). However, for both the attention module and the FFN, we design and employ innovative archi- tectures. For attention, we design MLA, which utilizes low-rank key-value joint compression to eliminate the bottleneck of inference-time key-value cache, thus supporting efficient inference. For FFNs, we adopt the\n\nDeepSeekMoE architecture (Dai et al., 2024), a high-performance MoE architecture that enables training strong models at an economical cost. An illustration of the architecture of DeepSeek-V2 is presented in Figure 2, and we will introduce the details of MLA and DeepSeekMoE in this section. For other tiny details (e.g., layer normalization and the activation function in FFNs), unless specifically stated, DeepSeek-V2 follows the settings of DeepSeek 67B (DeepSeek-AI, 2024).\n\n2.1. Multi-Head Latent Attention: Boosting Inference Efficiency\n\nConventional Transformer models usually adopts Multi-Head Attention (MHA) (Vaswani et al., 2017), but during generation, its heavy Key-Value (KV) cache will become the bottle- neck that limit the inference efficiency. In order to reduce the KV cache, Multi-Query Atten- tion (MQA) (Shazeer, 2019) and Grouped-Query Attention (GQA) (Ainslie et al., 2023) are proposed. They require a smaller magnitude of KV cache, but their performance does not match MHA (we provide the ablation of MHA, GQA and MQA\n\nin Appendix C.1).\n\nFor DeepSeek-V2, we design an innovative attention mechanism called Multi-head Latent Attention (MLA). Equipped with low-rank key-value joint compression, MLA achieves better performance than MHA, but requires a significantly smaller amount of KV cache. We introduce its architecture in the following, and also provide a comparison between MLA and MHA in Appendix C.2.\n\n2.1.1. Preliminaries: Standard Multi-Head Attention\n\nWe first introduce the standard MHA mechanism as background. Let ð‘‘ be the embedding dimension, ð‘›â„Ž be the number of attention heads, ð‘‘â„Ž be the dimension per head, and hð‘¡ âˆˆ Rð‘‘ be the attention input of the ð‘¡-th token at an attention layer. Standard MHA first produces qð‘¡, kð‘¡, vð‘¡ âˆˆ Rð‘‘â„Žð‘›â„Ž through three matrices ð‘Š ð‘„, ð‘Š ð¾, ð‘Šð‘‰ âˆˆ Rð‘‘â„Žð‘›â„Ž Ã—ð‘‘, respectively:\n\nqð‘¡ = ð‘Š ð‘„ kð‘¡ = ð‘Š ð¾ vð‘¡ = ð‘Šð‘‰\n\nhð‘¡, (1)\n\nhð‘¡, (2)\n\nhð‘¡, (3)\n\nThen, qð‘¡, kð‘¡, vð‘¡ will be sliced into ð‘›â„Ž heads for the multi-head attention computation:\n\n[qð‘¡,1;qð‘¡,2; ...; qð‘¡,ð‘›â„Ž] = qð‘¡, [kð‘¡,1;kð‘¡,2; ...; kð‘¡,ð‘›â„Ž] = kð‘¡, [vð‘¡,1;vð‘¡,2; ...; vð‘¡,ð‘›â„Ž] = vð‘¡,\n\n(4)\n\n(5)\n\n(6)\n\noð‘¡,ð‘– = ð‘¡ âˆ‘ï¸ ð‘—=1 Softmax ð‘— ( qð‘‡ ð‘¡,ð‘–k ð‘—,ð‘– âˆš ð‘‘â„Ž )v ð‘—,ð‘–, (7)\n\nuð‘¡ = ð‘Šð‘‚ [oð‘¡,1; oð‘¡,2; ...; oð‘¡,ð‘›â„Ž], (8)\n\n6\n\nXXX Cached During Inference 7\n\nLatent â€” â€” â€”. â€” â€” mâ€” 10000000 00 ;00000000 Multi-Head Attention (MHA) | Grouped-Query Attention (GQA) | Multi-Query Attention (MQA) | Multi-Head Latent Attention (MLA) - - - [ - - 11â€” - - 1= - - NSNSNRANR N N N N N 1 - wies NNNN NN AR Y N Y N \\ ! NENENENENENENEN N Â§ Â§ N N 1 N HE R H |55555555_ SISINESESESESEY N N Â§ N q N DONNNNNN N NN N H } f f i 1 1 1 \'\n\nFigure 3 | Simplified illustration of Multi-Head Attention (MHA), Grouped-Query Atten- tion (GQA), Multi-Query Attention (MQA), and Multi-head Latent Attention (MLA). Through jointly compressing the keys and values into a latent vector, MLA significantly reduces the KV cache during inference.\n\nwhere qð‘¡,ð‘–, kð‘¡,ð‘–, vð‘¡,ð‘– âˆˆ Rð‘‘â„Ž denote the query, key, and value of the ð‘–-th attention head, respectively; ð‘Šð‘‚ âˆˆ Rð‘‘Ã—ð‘‘â„Žð‘›â„Ž denotes the output projection matrix. During inference, all keys and values need to be cached to accelerate inference, so MHA needs to cache 2ð‘›â„Žð‘‘â„Žð‘™ elements for each token. In model deployment, this heavy KV cache is a large bottleneck that limits the maximum batch size and sequence length.\n\n2.1.2. Low-Rank Key-Value Joint Compression\n\nThe core of MLA is the low-rank joint compression for keys and values to reduce KV cache: ð‘¡ = ð‘Š ð·ð¾ð‘‰ ð¾ð‘‰ hð‘¡, ð‘¡ = ð‘Šð‘ˆ ð¾ ð¾ð‘‰ ð¶ c k ð‘¡ ð¾ð‘‰ ð‘¡ = ð‘Šð‘ˆð‘‰ ð¶ c v ð‘¡\n\n, (11)\n\nð‘¡ âˆˆ Rð‘‘ð‘ is the compressed latent vector for keys and values; ð‘‘ð‘ (â‰ª ð‘‘â„Žð‘›â„Ž) denotes the KV where cð¾ð‘‰ compression dimension; ð‘Š ð·ð¾ð‘‰ âˆˆ Rð‘‘ð‘ Ã—ð‘‘ is the down-projection matrix; and ð‘Šð‘ˆ ð¾, ð‘Šð‘ˆð‘‰ âˆˆ Rð‘‘â„Žð‘›â„Ž Ã—ð‘‘ð‘ are the up-projection matrices for keys and values, respectively. During inference, MLA only needs to cache cð¾ð‘‰ , so its KV cache has only ð‘‘ð‘ð‘™ elements, where ð‘™ denotes the number of layers. ð‘¡ In addition, during inference, since ð‘Šð‘ˆ ð¾ can be absorbed into ð‘Š ð‘„, and ð‘Šð‘ˆð‘‰ can be absorbed into ð‘Šð‘‚, we even do\n\nnot need to compute keys and values out for attention. Figure 3 intuitively illustrates how the KV joint compression in MLA reduces the KV cache.\n\nMoreover, in order to reduce the activation memory during training, we also perform low-rank compression for the queries, even if it cannot reduce the KV cache:\n\nð‘„ c (12)\n\nð‘¡ = ð‘Š ð·ð‘„ ð‘¡ = ð‘Šð‘ˆð‘„ ð¶ q\n\nhð‘¡, ð‘„ ð‘¡ ,\n\nc (13)\n\nð‘¡ âˆˆ Rð‘‘â€² ð‘„ ð‘ is the compressed latent vector for queries; ð‘‘â€² ð‘ (â‰ª ð‘‘â„Žð‘›â„Ž) denotes the query ð‘ are the down-projection and up- where c compression dimension; and ð‘Š ð·ð‘„ âˆˆ Rð‘‘â€² projection matrices for queries, respectively. ð‘ Ã—ð‘‘, ð‘Šð‘ˆð‘„ âˆˆ Rð‘‘â„Žð‘›â„Ž Ã—ð‘‘â€²\n\n2.1.3. Decoupled Rotary Position Embedding\n\nFollowing DeepSeek 67B (DeepSeek-AI, 2024), we intend to use the Rotary Position Embed- ding (RoPE) (Su et al., 2024) for DeepSeek-V2. However, RoPE is incompatible with low-rank\n\n7\n\nKV\n\n)\n\n(10)\n\nAttention Mechanism Multi-Head Attention (MHA) Grouped-Query Attention (GQA) Multi-Query Attention (MQA) MLA (Ours) KV Cache per Token (# Element) 2ð‘›â„Žð‘‘â„Žð‘™ 2ð‘›ð‘”ð‘‘â„Žð‘™ 2ð‘‘â„Žð‘™ ð‘‘â„Žð‘™ (ð‘‘ð‘ + ð‘‘ ð‘… â„Ž )ð‘™ â‰ˆ 9 2 Capability Strong Moderate Weak Stronger\n\nTable 1 | Comparison of the KV cache per token among different attention mechanisms. ð‘›â„Ž denotes the number of attention heads, ð‘‘â„Ž denotes the dimension per attention head, ð‘™ denotes the number of layers, ð‘›ð‘” denotes the number of groups in GQA, and ð‘‘ð‘ and ð‘‘ ð‘… â„Ž denote the KV compression dimension and the per-head dimension of the decoupled queries and key in MLA, respectively. The amount of KV cache is measured by the number of elements, regardless of the ð‘‘â„Ž storage precision. For DeepSeek-V2, ð‘‘ð‘\n\nis set to 4ð‘‘â„Ž and ð‘‘ ð‘… 2 . So, its KV cache is equal to GQA with only 2.25 groups, but its performance is stronger than MHA.\n\nKV compression. To be specific, RoPE is position-sensitive for both keys and queries. If we apply RoPE for the keys kð¶ ð‘¡ , ð‘Šð‘ˆ ð¾ in Equation 10 will be coupled with a position-sensitive RoPE matrix. In this way, ð‘Šð‘ˆ ð¾ cannot be absorbed into ð‘Š ð‘„ any more during inference, since a RoPE matrix related to the currently generating token will lie between ð‘Š ð‘„ and ð‘Šð‘ˆ ð¾ and matrix multiplication does not obey a commutative law. As a result, we must recompute the keys for all the prefix tokens during\n\ninference, which will significantly hinder the inference efficiency.\n\nAs a solution, we propose the decoupled RoPE strategy that uses additional multi-head queries qð‘… â„Ž denotes the per-head dimension of the decoupled queries and key. Equipped with the decoupled RoPE strategy, MLA performs the following computation:\n\nð‘„ ð‘¡ ), c hð‘¡),\n\n[q ð‘… ð‘¡,1; q ð‘… ð‘¡,2; ...; q ð‘… (14)\n\nð‘¡ = RoPE(ð‘Š ð‘„ð‘… ð‘… ð‘¡,ð‘›â„Ž] = q ð‘¡ = RoPE(ð‘Š ð¾ð‘… k ð¶ ð‘¡,ð‘–], qð‘¡,ð‘– = [q ð‘¡,ð‘–; q ð¶ ð‘… ð‘¡ ], kð‘¡,ð‘– = [k ð‘¡,ð‘–; k ð‘¡ âˆ‘ï¸\n\nð‘…\n\n(15)\n\nð‘…\n\n(16)\n\n(17)\n\nqð‘‡ ð‘¡,ð‘–k ð‘—,ð‘– âˆšï¸ƒ ð‘‘â„Ž + ð‘‘ ð‘… â„Ž uð‘¡ = ð‘Šð‘‚ [oð‘¡,1; oð‘¡,2; ...; oð‘¡,ð‘›â„Ž],\n\nSoftmax ð‘— ( oð‘¡,ð‘– = ð‘—=1 ð¶ )v ð‘—,ð‘–, (18)\n\n(19)\n\nwhere ð‘Š ð‘„ð‘… âˆˆ Rð‘‘ ð‘… are matrices to produce the decouples queries and key, respectively; RoPE(Â·) denotes the operation that applies RoPE matrices; and [Â·; Â·] denotes the concatenation operation. During inference, the decoupled key should also be cached. Therefore, DeepSeek-V2 requires a total KV cache containing (ð‘‘ð‘ + ð‘‘ ð‘…\n\nIn order to demonstrate the complete computation process of MLA, we also organize and provide its full formulas in Appendix B.\n\n2.1.4. Comparison of Key-Value Cache\n\nWe demonstrate a comparison of the KV cache per token among different attention mechanisms in Table 1. MLA requires only a small amount of KV cache, equal to GQA with only 2.25 groups, but can achieve stronger performance than MHA.\n\n8\n\n2.2. DeepSeekMoE: Training Strong Models at Economical Costs\n\n2.2.1. Basic Architecture\n\nFor FFNs, we employ the DeepSeekMoE architecture (Dai et al., 2024). DeepSeekMoE has two key ideas: segmenting experts into finer granularity for higher expert specialization and more accurate knowledge acquisition, and isolating some shared experts for mitigating knowledge redundancy among routed experts. With the same number of activated and total expert parame- ters, DeepSeekMoE can outperform conventional MoE architectures like GShard (Lepikhin et al., 2021) by a large margin.\n\nLet uð‘¡ be the FFN input of the ð‘¡-th token, we compute the FFN output hâ€²\n\nas follows:\n\nhâ€² ð‘¡ = uð‘¡ + ð‘ð‘ âˆ‘ï¸ FFN (ð‘ ) ð‘– (uð‘¡) + ð‘ð‘Ÿâˆ‘ï¸ ð‘”ð‘–,ð‘¡ FFN (ð‘Ÿ) ð‘– (uð‘¡), ð‘–=1 (20)\n\ni=1 Sit â‚¬ TOPk({Sj,z|1 <j<N}LK), otherwise, (u"e;),\n\ne = Sitr Sit â‚¬ 0, otherwise, si = Softmax;\n\nð‘”ð‘–,ð‘¡ = (21)\n\n(22)\n\nwhere ð‘ð‘  and ð‘ð‘Ÿ denote the numbers of shared experts and routed experts, respectively; FFN (Â·) (Â·) denote the ð‘–-th shared expert and the ð‘–-th routed expert, respectively; ð¾ð‘Ÿ denotes and FFN the number of activated routed experts; ð‘”ð‘–,ð‘¡ is the gate value for the ð‘–-th expert; ð‘ ð‘–,ð‘¡ is the token- to-expert affinity; eð‘– is the centroid of the ð‘–-th routed expert in this layer; and Topk(Â·, ð¾) denotes the set comprising ð¾ highest scores among the affinity scores calculated for the ð‘¡-th token and all\n\nrouted experts.\n\n2.2.2. Device-Limited Routing\n\nWe design a device-limited routing mechanism to bound MoE-related communication costs. When expert parallelism is employed, the routed experts will be distributed across multiple devices. For each token, its MoE-related communication frequency is proportional to the number of devices covered by its target experts. Due to the fine-grained expert segmentation in DeepSeekMoE, the number of activated experts can be large, so the MoE-related communication will be more costly if we apply expert\n\nparallelism.\n\nFor DeepSeek-V2, beyond the naive top-K selection of routed experts, we additionally ensure that the target experts of each token will be distributed on at most ð‘€ devices. To be specific, for each token, we first select ð‘€ devices that have experts with the highest affinity scores in them. Then, we perform top-K selection among experts on these ð‘€ devices. In practice, we find that when ð‘€ â©¾ 3, the device-limited routing can achieve a good performance roughly aligned with the unrestricted top-K\n\nrouting.\n\n2.2.3. Auxiliary Loss for Load Balance\n\nWe take the load balance into consideration for automatically learned routing strategies. Firstly, unbalanced load will raise the risk of routing collapse (Shazeer et al., 2017), preventing some experts being fully trained and utilized. Secondly, when expert parallelism is employed, unbal- anced load will diminish computation efficiency. During the training of DeepSeek-V2, we design three kinds of auxiliary losses, for controlling expert-level load balance (LExpBal), device-level load balance\n\n(LDevBal), and communication balance (LCommBal), respectively.\n\n9\n\nExpert-Level Balance Loss. We use an expert-level balance loss (Fedus et al., 2021; Lepikhin et al., 2021) to mitigate the risk of routing collapse:\n\nLExpBal = ð›¼1 ð‘ð‘Ÿâˆ‘ï¸ ð‘“ð‘– ð‘ƒð‘–, (23)\n\nð‘–=1\n\nð‘“ð‘– = ð‘ð‘Ÿ ð¾ð‘Ÿð‘‡ ð‘‡ âˆ‘ï¸ ð‘¡=1 1(Token ð‘¡ selects Expert ð‘–), (24)\n\nð‘ƒð‘– = 1 ð‘‡ ð‘‡ âˆ‘ï¸ ð‘ ð‘–,ð‘¡, (25)\n\nð‘¡=1\n\nwhere ð›¼1 is a hyper-parameter called expert-level balance factor; 1(Â·) denotes the indicator function; and ð‘‡ denotes the number of tokens in a sequence.\n\nDevice-Level Balance Loss. In addition to the expert-level balance loss, we additionally design a device-level balance loss to ensure balanced computation across different devices. In the training process of DeepSeek-V2, we partition all routed experts into ð· groups {E1, E2, ..., Eð·}, and deploy each group on a single device. The device-level balance loss is computed as follows:\n\nLDevBal = ð›¼2 ð· âˆ‘ï¸ ð‘– ð‘ƒâ€² ð‘“ â€² ð‘– , ð‘–=1 (26)\n\nð‘“ â€² ð‘– = 1 |Eð‘–| âˆ‘ï¸ ð‘—âˆˆ Eð‘– ð‘“ ð‘—, (27)\n\nð‘ƒâ€² ð‘– = âˆ‘ï¸ ð‘ƒ ð‘—, ð‘—âˆˆ Eð‘– (28)\n\nwhere ð›¼2 is a hyper-parameter called device-level balance factor.\n\nCommunication Balance Loss. Finally, we introduce a communication balance loss to ensure that the communication of each device is balanced. Although the device-limited routing mecha- nism guarantees that the sending communication of each device is bounded, if a certain device receives more tokens than other devices, the practical communication efficiency will also be affected. In order to mitigate this issue, we design a communication balance loss as follows:\n\nLCommBal = ð›¼3 ð· âˆ‘ï¸ ð‘– ð‘ƒâ€²â€² ð‘“ â€²â€² ð‘– , (29)\n\nð‘–=1 ð‘‡ âˆ‘ï¸\n\nð‘“ â€²â€² ð‘– = ð· ð‘€ð‘‡ 1(Token ð‘¡ is sent to Device ð‘–), (30)\n\nð‘¡=1 ð‘ƒ ð‘—,\n\nâˆ‘ï¸\n\nð‘ƒâ€²â€² ð‘– = ð‘—âˆˆ Eð‘– (31)\n\nwhere ð›¼3 is a hyper-parameter called communication balance factor. The device-limited routing mechanism operates on the principle of ensuring that each device transmits at most ð‘€ð‘‡ hidden states to other devices. Simultaneously, the communication balance loss is employed to encour- age each device to receive around ð‘€ð‘‡ hidden states from other devices. The communication balance loss guarantees a balanced exchange of information among devices, promoting efficient communications.\n\n10\n\n2.2.4. Token-Dropping Strategy\n\nWhile balance losses aim to encourage a balanced load, it is important to acknowledge that In order to further mitigate the computation they cannot guarantee a strict load balance. wastage caused by unbalanced load, we introduce a device-level token-dropping strategy during training. This approach first computes the average computational budget for each device, which means that the capacity factor for each device is equivalent to 1.0. Then, inspired by Riquelme et al. (2021), we drop tokens with\n\nthe lowest affinity scores on each device until reaching the computational budget. In addition, we ensure that the tokens belonging to approximately 10% of the training sequences will never be dropped. In this way, we can flexibly decide whether to drop tokens during inference according to the efficiency requirements, and always ensure consistency between training and inference.\n\n3. Pre-Training\n\n3.1. Experimental Setups\n\n3.1.1. Data Construction\n\nWhile maintaining the same data processing stages as for DeepSeek 67B (DeepSeek-AI, 2024), we extend the amount of data and elevate the data quality. In order to enlarge our pre-training corpus, we delve deeper into the potential of the internet data and optimize our cleaning processes, thus recovering a large amount of mistakenly deleted data. Moreover, we incorporate more Chinese data, aiming to better leverage the corpus available on the Chinese internet. In addition to the amount of data, we\n\nalso focus on the data quality. We enrich our pre-training corpus with high-quality data from various sources, and meanwhile improve the quality-based filtering algorithm. The improved algorithm ensures that a large amount of non-beneficial data will be removed, while the valuable data will be mostly retained. In addition, we filter out the contentious content from our pre-training corpus to mitigate the data bias introduced from specific regional cultures. A detailed discussion about the\n\ninfluence of this filtering strategy is presented in Appendix D.\n\nWe adopt the same tokenizer as used in DeepSeek 67B, which is built based on the Byte-level Byte-Pair Encoding (BBPE) algorithm and has a vocabulary size of 100K. Our tokenized pre- training corpus contains 8.1T tokens, where Chinese tokens are approximately 12% more than English ones.\n\n3.1.2. Hyper-Parameters\n\nModel Hyper-Parameters. We set the number of Transformer layers to 60 and the hidden dimension to 5120. All learnable parameters are randomly initialized with a standard deviation of 0.006. In MLA, we set the number of attention heads ð‘›â„Ž to 128 and the per-head dimension ð‘‘â„Ž to 128. The KV compression dimension ð‘‘ð‘ is set to 512, and the query compression dimension ð‘ is set to 1536. For the decoupled queries and key, we set the per-head dimension ð‘‘ ð‘… ð‘‘â€² â„Ž to 64. Following Dai et al. (2024), we\n\nsubstitute all FFNs except for the first layer with MoE layers. Each MoE layer consists of 2 shared experts and 160 routed experts, where the intermediate hidden dimension of each expert is 1536. Among the routed experts, 6 experts will be activated for each token. In addition, the low-rank compression and fine-grained expert segmentation will impact the output scale of a layer. Therefore, in practice, we employ additional RMS Norm layers after the compressed latent vectors, and multiply\n\nadditional scaling factors at the width bottlenecks (i.e., the compressed latent vectors and the intermediate hidden states of routed\n\n11\n\nexperts) to ensure stable training. Under this configuration, DeepSeek-V2 comprises 236B total parameters, of which 21B are activated for each token.\n\nTraining Hyper-Parameters. We employ the AdamW optimizer (Loshchilov and Hutter, 2017) with hyper-parameters set to ð›½1 = 0.9, ð›½2 = 0.95, and weight_decay = 0.1. The learning rate is scheduled using a warmup-and-step-decay strategy (DeepSeek-AI, 2024). Initially, the learning rate linearly increases from 0 to the maximum value during the first 2K steps. Subsequently, the learning rate is multiplied by 0.316 after training about 60% of tokens, and again by 0.316 after training about 90% of tokens.\n\nThe maximum learning rate is set to 2.4 Ã— 10âˆ’4, and the gradient clipping norm is set to 1.0. We also use a batch size scheduling strategy, where the batch size is gradually increased from 2304 to 9216 in the training of the first 225B tokens, and then keeps 9216 in the remaining training. We set the maximum sequence length to 4K, and train DeepSeek-V2 on 8.1T tokens. We leverage pipeline parallelism to deploy different layers of a model on different devices, and for each layer, the routed\n\nexperts will be uniformly deployed on 8 devices (ð· = 8). As for the device-limited routing, each token will be sent to at most 3 devices (ð‘€ = 3). As for balance losses, we set ð›¼1 to 0.003, ð›¼2 to 0.05, and ð›¼3 to 0.02. We employ the token-dropping strategy during training for acceleration, but do not drop any tokens for evaluation.\n\n3.1.3. Infrastructures\n\nDeepSeek-V2 is trained based on the HAI-LLM framework (High-flyer, 2023), an efficient and light-weight training framework developed internally by our engineers. It employs a 16-way zero-bubble pipeline parallelism (Qi et al., 2023), an 8-way expert parallelism (Lepikhin et al., 2021), and ZeRO-1 data parallelism (Rajbhandari et al., 2020). Given that DeepSeek-V2 has relatively few activated parameters, and a portion of the operators are recomputed to save acti- vation memory, it can be trained\n\nwithout the necessity of tensor parallelism, thereby decreasing the communication overhead. Moreover, in order to further improve the training efficiency, we overlap the computation of shared experts with the expert parallel all-to-all communication. We also customize faster CUDA kernels for communications, routing algorithms, and fused linear computations across different experts. In addition, MLA is also optimized based on an improved version of FlashAttention-2 (Dao, 2023).\n\nWe conduct all experiments on a cluster equipped with NVIDIA H800 GPUs. Each node in the H800 cluster contains 8 GPUs connected using NVLink and NVSwitch within nodes. Across nodes, InfiniBand interconnects are utilized to facilitate communications.\n\n3.1.4. Long Context Extension\n\nAfter the initial pre-training of DeepSeek-V2, we employ YaRN (Peng et al., 2023) to extend the default context window length from 4K to 128K. YaRN was specifically applied to the decoupled shared key kð‘… ð‘¡ as it is responsible for carrying RoPE (Su et al., 2024). For YaRN, we set the scale ð‘  to 40, ð›¼ to 1, ð›½ to 32, and the target maximum context length to 160K. Under these settings, we can expect the model to respond well for a context length of 128K. Slightly diverging from original YaRN, due\n\nto our distinct attention mechanism, we adjust the length scaling factor to ð‘¡ = 0.0707 ln ð‘  + 1, aiming at modulate the attention entropy. The factor minimizing the perplexity.\n\nWe additionally train the model for 1000 steps, with a sequence length of 32K and a batch size of 576 sequences. Although the training is conducted solely at the sequence length of 32K,\n\n12\n\nPressure Testing DeepSeek-V2 Base 128K Context via "Needle In A HayStack" 0 10 9 18 27 36 45 55 64 73 82 91 100 1 70K 81K 93K 104K 116K 128K Context Length (#Tokens) - w (<} ~ Â© 0 Score Document Depth Percent (%) w N\n\nFigure 4 | Evaluation results on the â€œNeedle In A Haystackâ€ (NIAH) tests. DeepSeek-V2 performs well across all context window lengths up to 128K.\n\nthe model still demonstrates robust performance when being evaluated at a context length of 128K. As shown in Figure 4, the results on the â€œNeedle In A Haystackâ€ (NIAH) tests indicate that DeepSeek-V2 performs well across all context window lengths up to 128K.\n\n3.2. Evaluations\n\n3.2.1. Evaluation Benchmarks\n\nDeepSeek-V2 is pretrained on a bilingual corpus, so we evaluate it on a series of benchmarks in English and Chinese. Our evaluation is based on our internal evaluation framework integrated in our HAI-LLM framework. Included benchmarks are categorized and listed as follows, where underlined benchmarks are in Chinese:\n\nMulti-subject multiple-choice datasets include MMLU (Hendrycks et al., 2020), C-Eval (Huang et al., 2023), and CMMLU (Li et al., 2023).\n\nLanguage understanding and reasoning datasets include HellaSwag (Zellers et al., 2019), PIQA (Bisk et al., 2020), ARC (Clark et al., 2018), and BigBench Hard (BBH) (Suzgun et al., 2022).\n\nClosed-book question answering datasets include TriviaQA (Joshi et al., 2017) and Natu- ralQuestions (Kwiatkowski et al., 2019).\n\nReading comprehension datasets include RACE Lai et al. (2017), DROP (Dua et al., 2019), C3 (Sun et al., 2019), and CMRC (Cui et al., 2019).\n\nReference disambiguation datasets include WinoGrande Sakaguchi et al. (2019) and CLUEWSC (Xu et al., 2020).\n\nLanguage modeling datasets include Pile (Gao et al., 2020).\n\nChinese understanding and culture datasets include CHID (Zheng et al., 2019) and CCPM (Li et al., 2021).\n\n13\n\nMath datasets include GSM8K (Cobbe et al., 2021), MATH (Hendrycks et al., 2021), and CMath (Wei et al., 2023).\n\nCode datasets include HumanEval (Chen et al., 2021), MBPP (Austin et al., 2021), and CRUXEval (Gu et al., 2024).\n\nStandardized exams include AGIEval (Zhong et al., 2023). Note that AGIEval includes both English and Chinese subsets.\n\nFollowing our previous work (DeepSeek-AI, 2024), we adopt perplexity-based evaluation for datasets including HellaSwag, PIQA, WinoGrande, RACE-Middle, RACE-High, MMLU, ARC-Easy, ARC-Challenge, CHID, C-Eval, CMMLU, C3, and CCPM, and adopt generation- based evaluation for TriviaQA, NaturalQuestions, DROP, MATH, GSM8K, HumanEval, MBPP, CRUXEval, BBH, AGIEval, CLUEWSC, CMRC, and CMath. In addition, we perform language- modeling-based evaluation for Pile-test and use Bits-Per-Byte (BPB) as the metric\n\nto guarantee fair comparison among models with different tokenizers.\n\nFor an intuitive overview of these benchmarks, we additionally provide our evaluation formats for each benchmark in Appendix F.\n\n3.2.2. Evaluation Results\n\nIn Table 2, we compare DeepSeek-V2 with several representative open-source models, includ- ing DeepSeek 67B (DeepSeek-AI, 2024) (our previous release), Qwen1.5 72B (Bai et al., 2023), LLaMA3 70B (AI@Meta, 2024), and Mixtral 8x22B (Mistral, 2024). We evaluate all these models with our internal evaluation framework, and ensure that they share the same evaluation setting. Overall, with only 21B activated parameters, DeepSeek-V2 significantly outperforms DeepSeek 67B on almost all benchmarks, and\n\nachieves top-tier performance among open-source models.\n\nFurther, we elaborately compare DeepSeek-V2 with its open-source counterparts one by one. (1) Compared with Qwen1.5 72B, another model that supports both Chinese and English, DeepSeek-V2 demonstrates overwhelming advantages on the majority of English, code, and math benchmarks. As for Chinese benchmarks, Qwen1.5 72B shows better performance on multi-subject multiple-choice tasks while DeepSeek-V2 is comparable or better on others. Note that for the CHID benchmark, the tokenizer of Qwen1.5 72B\n\nwill encounter errors in our evaluation framework, so we leave the CHID score blank for Qwen1.5 72B. (2) Compared with Mixtral 8x22B, DeepSeek-V2 achieves comparable or better English performance, except for TriviaQA, NaturalQuestions, and HellaSwag, which are closely related to English commonsense knowledge. Notably, DeepSeek-V2 outperforms Mixtral 8x22B on MMLU. On code and math benchmarks, DeepSeek-V2 demonstrates comparable performance with Mixtral 8x22B. Since Mixtral 8x22B is not\n\nspecifically trained on Chinese data, its Chinese capability lags far behind DeepSeek-V2. (3) Compared with LLaMA3 70B, DeepSeek-V2 is trained on fewer than a quarter of English tokens. Therefore, we acknowledge that DeepSeek-V2 still has a slight gap in basic English capabilities with LLaMA3 70B. However, even with much fewer training tokens and activated parameters, DeepSeek-V2 still demonstrates comparable code and math capability with LLaMA3 70B. Also, as a bilingual language model,\n\nDeepSeek-V2 outperforms LLaMA3 70B overwhelmingly on Chinese benchmarks.\n\nFinally, it is worth mentioning that certain prior studies (Hu et al., 2024) incorporate SFT data during the pre-training stage, whereas DeepSeek-V2 has never been exposed to SFT data during pre-training.\n\n14\n\nBenchmark (Metric) # Shots DeepSeek Qwen1.5 Mixtral LLaMA 3 67B 72B 8x22B 70B Architecture # Activated Params # Total Params - - - Dense 67B 67B Dense 72B 72B MoE 39B 141B Dense 70B 70B MoE 21B 236B Pile-test (BPB) BBH (EM) MMLU (Acc.) DROP (F1) ARC-Easy (Acc.) ARC-Challenge (Acc.) HellaSwag (Acc.) PIQA (Acc.) WinoGrande (Acc.) RACE-Middle (Acc.) RACE-High (Acc.) TriviaQA (EM) NaturalQuestions (EM) AGIEval (Acc.) - 3-shot 5-shot 3-shot 25-shot 25-shot 10-shot 0-shot 5-shot 5-shot 5-shot 5-shot\n\n5-shot 0-shot 0.642 68.7 71.3 69.7 95.3 86.4 86.3 83.6 84.9 69.9 50.7 78.9 36.6 41.3 0.637 59.9 77.2 71.5 97.1 92.8 85.8 83.3 82.4 63.4 47.0 73.1 35.6 64.4 0.623 78.9 77.6 80.4 97.3 91.2 86.6 83.6 83.7 73.3 56.7 82.1 39.6 43.4 0.602 81.0 78.9 82.5 97.9 93.3 87.9 85.0 85.7 73.3 57.9 81.6 40.2 49.8 0.606 78.9 78.5 80.1 97.6 92.4 84.2 83.7 84.9 73.1 52.7 79.9 38.7 51.2 HumanEval (Pass@1) MBPP (Pass@1) CRUXEval-I (Acc.) CRUXEval-O (Acc.) 0-shot 3-shot 2-shot 2-shot 45.1 57.4 42.5 41.0 43.9 53.6 44.3\n\n42.3 53.1 64.2 52.4 52.8 48.2 68.6 49.4 54.3 48.8 66.6 52.8 49.8 GSM8K (EM) MATH (EM) CMath (EM) 8-shot 4-shot 3-shot 63.4 18.7 63.0 77.9 41.4 77.8 80.3 42.5 72.3 83.0 42.2 73.9 79.2 43.6 78.7\n\n\n\n\n\n\n\n\n\n\n\nEnglish\n\nChinese\n\nTable 2 | Comparison among DeepSeek-V2 and other representative open-source models. All models are evaluated in our internal framework and share the same evaluation setting. Bold denotes the best and underline denotes the second-best. Scores with a gap smaller than 0.3 are regarded as at the same level. With only 21B activated parameters, DeepSeek-V2 achieves top-tier performance among open-source models.\n\n3.2.3. Training and Inference Efficiency\n\nTraining Costs. Since DeepSeek-V2 activates fewer parameters for each token and requires fewer FLOPs than DeepSeek 67B, training DeepSeek-V2 will be more economical than training DeepSeek 67B theoretically. Although training an MoE model will introduce additional commu- nication overheads, through our operator and communication optimizations, the training for DeepSeek-V2 can attain a relatively high Model FLOPs Utilization (MFU). During our practical training on the H800 cluster, for training on\n\neach trillion tokens, DeepSeek 67B requires 300.6K GPU hours, while DeepSeek-V2 needs only 172.8K GPU hours, i.e., sparse DeepSeek-V2 can save 42.5% training costs compared with dense DeepSeek 67B.\n\nInference Efficiency. In order to efficiently deploy DeepSeek-V2 for service, we first convert its parameters into the precision of FP8. In addition, we also perform KV cache quantiza-\n\n15\n\ntion (Hooper et al., 2024; Zhao et al., 2023) for DeepSeek-V2 to further compress each element in its KV cache into 6 bits on average. Benefiting from MLA and these optimizations, actually deployed DeepSeek-V2 requires significantly less KV cache than DeepSeek 67B, and thus can serve a much larger batch size. We evaluate the generation throughput of DeepSeek-V2 based on the prompt and generation length distribution from the actually deployed DeepSeek 67B service. On a single node with 8 H800\n\nGPUs, DeepSeek-V2 achieves a generation throughput exceeding 50K tokens per second, which is 5.76 times the maximum generation throughput of DeepSeek 67B. In addition, the prompt input throughput of DeepSeek-V2 exceeds 100K tokens per second.\n\n4. Alignment\n\n4.1. Supervised Fine-Tuning\n\nBuilding upon our prior research (DeepSeek-AI, 2024), we curate our instruction tuning datasets to include 1.5M instances, comprising 1.2M instances for helpfulness and 0.3M instances for safety. In comparison to the initial version, we improve the data quality to mitigate hallucinatory responses and enhance writing proficiency. We fine-tune DeepSeek-V2 with 2 epochs, and the learning rate is set to 5 Ã— 10âˆ’6. For the evaluation of DeepSeek-V2 Chat (SFT), we mainly include generation-based\n\nbenchmarks, except for several representative multiple-choice tasks (MMLU and ARC). We also conduct an instruction-following evaluation (IFEval) (Zhou et al., 2023) for DeepSeek-V2 Chat (SFT), using prompt-level loose accuracy as the metric. Moreover, we employ LiveCodeBench (Jain et al., 2024) questions from September 1st, 2023 to April 1st, 2024 to evaluate chat models. In addition to the standard benchmarks, we further evaluate our model on open-ended conversation benchmarks including\n\nMT-Bench (Zheng et al., 2023), AlpacaEval 2.0 (Dubois et al., 2024), and AlignBench (Liu et al., 2023). For comparison, we also evaluate Qwen1.5 72B Chat, LLaMA-3-70B Instruct, and Mistral-8x22B Instruct in our evaluation framework and settings. As for DeepSeek 67B Chat, we directly refer to the evaluation results reported in our previous release.\n\n4.2. Reinforcement Learning\n\nIn order to further unlock the potential of DeepSeek-V2 and align it with human preference, we conduct Reinforcement Learning (RL) to adjust its preference.\n\nReinforcement Learning Algorithm. In order to save the training costs of RL, we adopt Group Relative Policy Optimization (GRPO) (Shao et al., 2024), which foregoes the critic model that is typically with the same size as the policy model, and estimates the baseline from group scores instead. Specifically, for each question ð‘ž, GRPO samples a group of outputs {ð‘œ1, ð‘œ2, Â· Â· Â· , ð‘œðº} from the old policy ðœ‹ðœƒð‘œð‘™ð‘‘ and then optimizes the policy model ðœ‹ðœƒ by maximizing the following objective:\n\nJorro(0) = E[q ~ P(Q),{0:}S, 1Â¢ mo(oda) â€” min GZl( (negmlq)\n\n= E[q ~ P(Q),{0:}S, ~ m6,,(0lq)] 1Â¢ mo(oda) |, .. [ 7o(oilg) ) ) (32) â€” min A, cli ,1â€”Â¢,1+Â¢| Ai| â€” BDky (7ol|7res) | , GZl( (negmlq) P\\ (ol ADs (mollre)\n\nTref(0i Tref(0i D (egllne) = ZLCID o0 AresCoil) 33) Toloda) 8 xolole)\n\n16\n\nwhere ðœ€ and ð›½ are hyper-parameters; and ð´ð‘– is the advantage, computed using a group of rewards {ð‘Ÿ1, ð‘Ÿ2, . . . , ð‘Ÿðº} corresponding to the outputs within each group:\n\nð´ð‘– = ð‘Ÿð‘– âˆ’ mð‘’ð‘Žð‘›({ð‘Ÿ1, ð‘Ÿ2, Â· Â· Â· , ð‘Ÿðº}) sð‘¡ð‘‘({ð‘Ÿ1, ð‘Ÿ2, Â· Â· Â· , ð‘Ÿðº}) . (34)\n\nTraining Strategy. In our preliminary experiments, we find that the RL training on reasoning data, such as code and math prompts, exhibits unique characteristics that are distinct from the training on general data. For example, the mathematical and coding abilities of our model can keep improving over a longer period of training steps. Therefore, we employ a two-stage RL training strategy, which first performs reasoning alignment, and then performs human prefer- ence alignment. In the first\n\nreasoning alignment stage, we train a reward model ð‘…ð‘€ð‘Ÿð‘’ð‘Žð‘ ð‘œð‘›ð‘–ð‘›ð‘” for code and math reasoning tasks, and optimize the policy model with the feedback of ð‘…ð‘€ð‘Ÿð‘’ð‘Žð‘ ð‘œð‘›ð‘–ð‘›ð‘”:\n\nð‘Ÿð‘– = ð‘…ð‘€ð‘Ÿð‘’ð‘Žð‘ ð‘œð‘›ð‘–ð‘›ð‘” (ð‘œð‘–). (35)\n\nIn the second human preference alignment stage, we adopt a multi-reward framework, which acquires rewards from a helpful reward model ð‘…ð‘€â„Žð‘’ð‘™ ð‘ ð‘“ ð‘¢ð‘™, a safety reward model ð‘…ð‘€ð‘ ð‘Ž ð‘“ ð‘’ð‘¡ ð‘¦, and a rule-based reward model ð‘…ð‘€ð‘Ÿð‘¢ð‘™ð‘’. The final reward of a response ð‘œð‘– is\n\nð‘Ÿð‘– = ð‘1 Â· ð‘…ð‘€â„Žð‘’ð‘™ ð‘ ð‘“ ð‘¢ð‘™ (ð‘œð‘–) + ð‘2 Â· ð‘…ð‘€ð‘ ð‘Ž ð‘“ ð‘’ð‘¡ ð‘¦ (ð‘œð‘–) + ð‘3 Â· ð‘…ð‘€ð‘Ÿð‘¢ð‘™ð‘’(ð‘œð‘–), (36)\n\nwhere ð‘1, ð‘2, and ð‘3 are corresponding coefficients.\n\nIn order to obtain reliable reward models that play crucial roles in the RL training, we carefully collect preference data, and meticulously conduct quality filtering and proportion adjustments. We obtain code preference data based on compiler-feedback, and mathematical preference data based on the ground-truth labels. For reward model training, we initialize the reward models with DeepSeek-V2 Chat (SFT) and train them with either a point-wise or a pair-wise loss. In our experiments, we observe\n\nthat the RL training can fully tap into and activate the potential of our model, enabling it to select the correct and satisfactory answer from possible responses.\n\nOptimizations for Training Efficiency. Conducting RL training on extremely large models places high demands on the training framework. It requires careful engineering optimization to manage the GPU memory and RAM pressure, and meanwhile maintain a fast training speed. For this goal, we implement the following engineering optimizations. (1) Firstly, we propose a hybrid engine that adopts different parallel strategies for training and inference respectively to achieve higher GPU utilization. (2)\n\nSecondly, we leverage vLLM (Kwon et al., 2023) with large batch sizes as our inference backend to accelerate the inference speed. (3) Thirdly, we carefully design a scheduling strategy for offloading models to CPUs and loading models back to GPUs, which achieves a near-optimal balance between the training speed and memory consumption.\n\n4.3. Evaluation Results\n\nEvaluations on Standard Benchmarks. Initially, we evaluate DeepSeek-V2 Chat (SFT) and DeepSeek-V2 Chat (RL) on standard benchmarks. Notably, DeepSeek-V2 Chat (SFT) demon- strates substantial improvements in GSM8K, MATH, and HumanEval evaluations compared with its base version. This progress can be attributed to the inclusion of our SFT data, which comprises a considerable volume of math and code related content. In addition, DeepSeek-V2\n\n17\n\nBenchmark # Shots Chat (RL) Context Length - - Architecture # Activated Params - - # Total Params 4K Dense 67B 67B 32K Dense 72B 72B 8K Dense 70B 70B 64K MoE 39B 141B 128K MoE 21B 236B 128K MoE 21B 236B 5-shot NaturalQuestions 5-shot 5-shot 25-shot 25-shot 3-shot 0-shot 0-shot TriviaQA MMLU ARC-Easy ARC-Challenge BBH AGIEval IFEval 81.5 47.0 71.1 96.6 88.9 71.7 46.4 55.5 79.6 46.9 76.2 96.8 91.7 65.9 62.8 57.3 69.1 44.6 80.3 96.9 92.6 80.1 56.6 79.7 80.0 54.9 77.8 97.1 90.0 78.4 41.4 72.1 85.4\n\n51.9 78.4 97.6 92.5 81.3 63.2 64.1 86.7 53.4 77.8 98.1 92.3 79.7 61.4 63.8 Code 0-shot 3-shot CRUXEval-I-COT 2-shot CRUXEval-O-COT 2-shot 0-shot HumanEval MBPP LiveCodeBench 73.8 61.4 49.1 50.9 18.3 68.9 52.2 51.4 56.5 18.8 76.2 69.8 61.1 63.6 30.5 75.0 64.4 59.4 63.6 25.0 76.8 70.4 59.5 60.7 28.7 81.1 72.0 61.5 63.0 32.5 Math GSM8K MATH CMath 8-shot 4-shot 0-shot 84.1 32.6 80.3 81.9 40.6 82.8 93.2 48.5 79.2 87.9 49.8 75.1 90.8 52.7 82.0 92.2 53.9 81.9 CLUEWSC C-Eval CMMLU 5-shot 5-shot 5-shot\n\n78.5 65.2 67.8 90.1 82.2 82.9 85.4 67.9 70.7 75.8 60.0 61.0 88.6 80.9 82.4 89.9 78.0 81.6\n\n\n\n\n\n\n\n\n\nDeepSeek Qwen 1.5 LLaMA3 Mixtral DeepSeek-V2 DeepSeek-V2 67B Chat 72B Chat 70B Inst. 8x22B Inst. Chat (SFT)\n\nTable 3 | Comparison among DeepSeek-V2 Chat (SFT), DeepSeek-V2 Chat (RL), and other representative open-source chat models. Regarding TriviaQA and NaturalQuestions, it is worth noting that chat models, such as LLaMA3 70B Instruct, might not strictly adhere to the format constraints typically specified in the few-shot setting. Consequently, this can lead to underestimation of certain models in our evaluation framework.\n\nChat (RL) further boosts the performance on math and code benchmarks. We show more code and math evaluations in Appendix E.\n\nAs for the comparisons with other models, we first compare DeepSeek-V2 Chat (SFT) with Qwen1.5 72B Chat, and find that DeepSeek-V2 Chat (SFT) surpasses Qwen1.5 72B Chat on almost all of English, math, and code benchmarks. On Chinese benchmarks, DeepSeek- V2 Chat (SFT) demonstrates slightly lower scores than Qwen1.5 72B Chat on multi-subject multiple-choice tasks, consistent with the performance observed from their base versions. When compared with the state-of-the-art open-source MoE model,\n\nMixtral 8x22B Instruct, DeepSeek- V2 Chat (SFT) exhibits better performance on most benchmarks, except for NaturalQuestions and IFEval. Furthermore, in comparison to the state-of-the-art open-source model LLaMA3 70B Chat, DeepSeek-V2 Chat (SFT) shows similar performance in code and math related benchmarks. LLaMA3 70B Chat exhibits better performance on MMLU and IFEval, while DeepSeek-V2 Chat (SFT) showcases stronger performance on Chinese tasks. Ultimately, DeepSeek-V2 Chat (RL) demonstrates\n\nfurther enhanced performance in both mathematical and coding tasks compared with DeepSeek-V2 Chat (SFT). These comparisons highlight the strengths of DeepSeek-V2 Chat in relation to other language models in various domains and languages.\n\nEvaluations on Open-Ended Generation. We proceed with additional evaluations of our models on open-ended conversation benchmarks. For English open-ended conversation genera-\n\n18\n\nModel DeepSeek 67B Chat Mistral 8x22B Instruct v0.1 Qwen1.5 72B Chat LLaMA3 70B Instruct DeepSeek-V2 Chat (SFT) DeepSeek-V2 Chat (RL) 8.35 8.66 8.61 8.95 8.62 8.97 16.6 30.9 36.6 34.4 30.0 38.9\n\nMT-Bench AlpacaEval 2.0\n\nTable 4 | English open-ended conversation evaluations. For AlpacaEval 2.0, we use the length- controlled win rate as the metric.\n\ntion, we utilize MT-Bench and AlpacaEval 2.0 as the benchmarks. Evaluation results presented in Table 4 demonstrate a significant performance advantage of DeepSeek-V2 Chat (RL) over DeepSeek-V2 Chat (SFT). This outcome showcases the effectiveness of our RL training in achiev- ing improved alignment. In comparison to other open-source models, DeepSeek-V2 Chat (RL) demonstrates superior performance over Mistral 8x22B Instruct and Qwen1.5 72B Chat on both benchmarks. When compared with LLaMA3 70B\n\nInstruct, DeepSeek-V2 Chat (RL) showcases competitive performance on MT-Bench and notably outperforms it on AlpacaEval 2.0. These results highlight the strong performance of DeepSeek-V2 Chat (RL) in generating high-quality and contextually relevant responses, particularly in instruction-based conversation tasks.\n\nIn addition, we evaluate the Chinese open-ended generation capability based on AlignBench. As presented in Table 5, DeepSeek-V2 Chat (RL) exhibits a slight advantage over DeepSeek-V2 Chat (SFT). Notably, DeepSeek-V2 Chat (SFT) surpasses all open-source Chinese models by a significant margin. It significantly outperforms the second-best open-source model, Qwen1.5 72B Chat on both Chinese reasoning and language. Moreover, both DeepSeek-V2 Chat (SFT) and DeepSeek-V2 Chat (RL) outperform GPT-4-0613\n\nand ERNIEBot 4.0, solidifying the position of our models in the top-tier LLMs that support Chinese. Specifically, DeepSeek-V2 Chat (RL) shows remarkable performance in Chinese language understanding, which outperforms all models including GPT-4-Turbo-1106-Preview. On the other hand, the reasoning capability of DeepSeek-V2 Chat (RL) still lags behind giant models, such as Erniebot-4.0 and GPT-4s.\n\n4.4. Discussion\n\nAmount of SFT Data. The discussion surrounding the necessity of a large SFT corpus has been a topic of intense debate. Previous works (Young et al., 2024; Zhou et al., 2024) argue that fewer than 10K instances of SFT data are enough to produce satisfactory results. However, in our experiments, we observe a significant performance decline on the IFEval benchmark if we use fewer than 10K instances. A possible explanation is that, a language model necessitates a certain amount of data to develop\n\nspecific skills. Although the requisite data amount may diminish with the model size increasing, it cannot be entirely eliminated. Our observation underscores the critical need for sufficient data to equip an LLM with desired capabilities. Moreover, the quality of SFT data is also crucial, especially for tasks involving writing or open-ended questions.\n\nAlignment Tax of Reinforcement Learning. During human preference alignment, we observe a significant performance enhancement on the open-ended generation benchmarks, in terms of the scores rated by both AI and human evaluators. However, we also notice a phenomenon of â€œalignment taxâ€ (Ouyang et al., 2022), i.e., the alignment process can negatively impact the\n\n19\n\nModel Overall æ¨¡åž‹ æ€»åˆ† Avg. Math. Logi. Avg. Fund. Chi. Open. Writ. Role. Pro. ä¸“ä¸š æŽ¨ç† èƒ½åŠ› æ€»åˆ† æ•°å­¦ è®¡ç®— é€»è¾‘ æŽ¨ç† è¯­è¨€ æ€»åˆ† åŸºæœ¬ ä»»åŠ¡ ä¸­æ–‡ ç†è§£ ç»¼åˆ é—®ç­” æ–‡æœ¬ å†™ä½œ è§’è‰² æ‰®æ¼” 8.01 GPT-4-1106-Preview 7.91 DeepSeek-V2 Chat (RL) ERNIEBot-4.0-202404*ï¼ˆæ–‡å¿ƒä¸€è¨€ï¼‰ 7.89 7.74 DeepSeek-V2 Chat (SFT) 7.53 GPT-4-0613 ERNIEBot-4.0-202312*ï¼ˆæ–‡å¿ƒä¸€è¨€ï¼‰ 7.36 Moonshot-v1-32k-202404*ï¼ˆæœˆä¹‹æš—é¢ï¼‰ 7.22 7.19 Qwen1.5-72B-Chat* 6.43 DeepSeek-67B-Chat ChatGLM-Turboï¼ˆæ™ºè°±æ¸…è¨€ï¼‰ 6.24 ERNIEBot-3.5ï¼ˆæ–‡å¿ƒä¸€è¨€ï¼‰ 6.14 6.12 Yi-34B-Chat* 6.08 GPT-3.5-Turbo-0613 ChatGLM-Proï¼ˆæ™ºè°±æ¸…è¨€ï¼‰ 5.83\n\nSparkDesk-V2ï¼ˆè®¯é£žæ˜Ÿç«ï¼‰ 5.74 5.72 Qwen-14B-Chat 5.25 Baichuan2-13B-Chat 4.97 ChatGLM3-6B 4.97 Baichuan2-7B-Chat 4.96 InternLM-20B 4.91 Qwen-7B-Chat 4.48 ChatGLM2-6B 3.65 InternLM-Chat-7B 3.57 Chinese-LLaMA-2-7B-Chat 3.35 LLaMA-2-13B-Chinese-Chat 7.73 7.45 7.61 7.30 7.47 6.84 6.42 6.45 5.75 5.00 5.15 4.86 5.35 4.65 4.73 4.81 3.92 3.85 3.66 3.66 3.73 3.39 2.56 2.68 2.47 7.80 7.77 7.81 7.34 7.56 7.00 6.41 6.58 5.71 4.74 5.03 4.97 5.68 4.54 4.71 4.91 3.76 3.55 3.56 3.39 3.62 3.16 2.45 2.29 2.21 7.66 7.14\n\n7.41 7.26 7.37 6.67 6.43 6.31 5.79 5.26 5.27 4.74 5.02 4.75 4.74 4.71 4.07 4.14 3.75 3.92 3.83 3.61 2.66 3.07 2.73 8.29 8.36 8.17 8.17 7.59 7.88 8.02 7.93 7.11 7.49 7.13 7.38 6.82 7.01 6.76 6.63 6.59 6.10 6.28 6.26 6.09 5.58 4.75 4.46 4.23 7.99 8.10 7.56 8.04 7.81 7.47 7.82 7.38 7.12 6.82 6.62 6.72 6.71 6.51 5.84 6.90 6.22 5.75 5.81 5.96 6.40 4.91 4.34 4.31 4.13 7.33 8.28 8.53 8.26 6.93 7.88 7.58 7.77 6.52 7.17 7.60 7.28 5.81 6.76 6.97 6.36 6.05 5.29 5.50 5.50 5.74 4.52 4.09 4.26 3.31 8.61 8.37\n\n8.13 8.13 7.42 8.05 8.00 8.15 7.58 8.16 7.26 7.76 7.29 7.47 7.29 6.74 7.11 6.71 7.13 7.18 6.26 6.66 5.82 4.50 4.79 8.67 8.53 8.45 8.00 7.93 8.19 8.22 8.02 7.20 7.77 7.56 7.44 7.03 7.07 7.18 6.64 6.97 6.83 6.84 6.19 6.31 6.25 4.89 4.63 3.93 8.47 8.33 8.24 8.10 7.51 7.84 8.19 8.05 6.91 7.76 6.83 7.58 7.28 7.34 6.92 6.59 6.75 6.28 6.53 6.49 6.19 6.08 5.32 4.91 4.53 8.65 8.53 8.09 8.49 7.94 7.85 8.29 8.24 7.37 7.24 6.90 7.53 6.77 6.89 6.34 6.56 6.43 5.73 5.84 6.22 5.66 5.08 4.06 4.13 4.71\n\n\n\n\n\n\n\n\n\n\n\n\n\nTable 5 | AlignBench leaderboard rated by GPT-4-0613. Models are ranked in descending order based on the overall score. Models marked with * represent that we evaluate them through their API service or open-weighted model, instead of referring to the results reported in their original papers. Suffixes of Erniebot-4.0 and Moonshot denote the timestamps when we called their API.\n\nperformance on some standard benchmarks such as BBH. In order to alleviate the alignment tax, during the RL stage, we make significant efforts in data processing and improving training strategies, finally achieving a tolerable trade-off between the performance on standard and open-ended benchmarks. Exploring how to align a model with human preferences without compromising its general performance presents a valuable direction for future research.\n\nOnline Reinforcement Learning. In our preference alignment experiments, we find that the online approach significantly outperforms the offline approach. Therefore, we invest tremendous efforts in implementing an online RL framework for aligning DeepSeek-V2. The conclusion about online or offline preference alignment can vary in different contexts, and we reserve a more thorough comparison and analysis between them for future work.\n\n5. Conclusion, Limitation, and Future Work\n\nIn this paper, we introduce DeepSeek-V2, a large MoE language model that supports 128K context length. In addition to strong performance, it is also characterized by economical training and efficient inference, benefiting from its innovative architecture including MLA and DeepSeekMoE. In practice, compared with DeepSeek 67B, DeepSeek-V2 achieves significantly stronger performance, and meanwhile saves 42.5% of training costs, reduces the KV cache\n\n20\n\nby 93.3%, and boosts the maximum generation throughput to 5.76 times. Evaluation results further demonstrate that with only 21B activated parameters, DeepSeek-V2 achieves top-tier performance among open-source models and becomes the strongest open-source MoE model.\n\nDeepSeek-V2 and its chat versions share the acknowledged limitations commonly found in other LLMs, including the lack of ongoing knowledge updates after pre-training, the possibility of generating non-factual information such as unverified advice, and a chance to produce hallucinations. In addition, since our data primarily consist of Chinese and English content, our model may exhibit limited proficiency in other languages. In scenarios beyond Chinese and English, it should be used with caution.\n\nDeepSeek will continuously invest in open-source large models with longtermism, aiming to progressively approach the goal of artificial general intelligence.\n\nIn our ongoing exploration, we are dedicated to devising methods that enable further scaling up MoE models while maintaining economical training and inference costs. The goal of our next step is to achieve performance on par with GPT-4 in our upcoming release. â€¢ Our alignment team continuously strives to enhance our models, aiming to develop a model that is not only helpful but also honest and safe for worldwide users. Our ultimate objective is to align the values of our model with human values,\n\nwhile minimizing the need for human supervision. By prioritizing ethical considerations and responsible development, we are dedicated to creating a positive and beneficial impact on society. â€¢ Currently, DeepSeek-V2 is designed to support the text modality exclusively. In our forward-looking agenda, we intend to enable our model to support multiple modalities, enhancing its versatility and utility in a wider range of scenarios.\n\n""")